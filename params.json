{"name":"RSSDP","tagline":"Really Simple Service Discovery Protocol - a 100% .Net implementation of the SSDP protocol for publishing custom/basic devices, and discovering all device types on a network.","body":"# (Really) Simple Service Discovery Protocol For .Net\r\n\r\n## What is RSSDP ?\r\nRSSDP is a 100% .Net implementation of the Simple Service Discovery (SSDP) protocol that is part of the Universal Plug and Play (UPnP) standard. SSDP allows you\r\nto discover devices and services on a (local) network.\r\n\r\nRSSDP is designed primarily to publish and discover custom or 'basic' devices, and as such does not implement the full UPnP device architecture. If you are \r\nlooking to build a device for which a full UPnP device schema exists, this is not the library for you (sorry! though I guess you can fork and extend if you like).\r\nIf you are looking for a way to discover a custom service (such as a proprietary REST or SOAP service) from a device, RSSDP might be the solution for you.\r\n\r\n## Supported Platforms\r\nCurrently;\r\n\r\n* .Net Framework 4.0+\r\n* Windows Phone Silverlight (8.0+) (works with Xamarin.Forms 1.3+ too)\r\n* Xamarin.iOS Unified (works with Xamarin.Forms 1.3+  too)\r\n\r\nPlanned;    \r\n*eventually*\r\n\r\n* Xamarin.Android (including Xamarin.Forms Android projects)\r\n* Possibly WinRT (though it has it's own in-built API's for device location)\r\n* Possibly Windows CE/Compact Framework (VS 2008 Smart Device Projects)\r\n\r\n## How do I use RSSDP?\r\n*We got your samples right here*\r\n\r\nThere is a sample console applicaton included in the repository. If you don't want to \"read the source, Luke\", then here's some tips and examples to get you started.\r\n\r\n**One common gotcha to look out for:** SSDP root devices must publish an xml document describing themselves and any embedded devices, and this document must be published on a url that can be accessed via an HTTP GET.\r\nRSSDP will return devices in search results and notifications regardless of whether this document is actually accessible (it is up to you to retrieve the document if you care, and handle any exceptions that occur doing so).\r\nHowever, many other SSDP device locators (such as Intel's Device Spy application) will not report devices if the url cannot be accessed, the document is invalid, or data in the document (such as the UUID) does not \r\nmatch the associated notification or search request. For this reason, if you are using another tool to locate devices published with RSSDP, ensure you are publishing a correct document on the url specified in the Location\r\nproperty of your root device, or else the device may not be found. \r\n\r\nInstall the Nuget package like this;\r\n\r\n```powershell\r\n    PM> Install-Package Rssdp\r\n```\r\n\r\nOr reference the Rssdp.Portable.dll assembly AND the assembly that matches your app's platform, i.e Rssdp.NetFX40.dll for .Net 4+.\r\n\r\n### Publishing a Device\r\nOnly three steps to do this. Create a device definition, create a publisher, add the device to the publisher;\r\n\r\n```C#\r\n\r\nusing Rssdp;\r\n// Declare \\_Publisher as a field somewhere, so it doesn't get GCed after the method finishes.\r\nprivate SsdpDevicePublisher _Publisher;\r\n\r\n// Call this method from somewhere to actually do the publish.\r\npublic void PublishDevice()\r\n{\r\n    // As this is a sample, we are only setting the minimum required properties.\r\n    var deviceDefinition = new SsdpRootDevice()\r\n    {\r\n    \tCacheLifetime = TimeSpan.FromMinutes(30), //How long SSDP clients can cache this info.\r\n    \tLocation = new Uri(\"http://mydevice/descriptiondocument.xml\"), // Must point to the URL that serves your devices UPnP description document. \r\n    \tDeviceTypeNamespace = \"my-namespace\",\r\n    \tDeviceType = \"MyCustomDevice\",\r\n    \tFriendlyName = \"Custom Device 1\",\r\n    \tManufacturer = \"Me\",\r\n    \tModelName = \"MyCustomDevice\",\r\n    \tUuid = GetPersistentUuid() // This must be a globally unique value that survives reboots etc. Get from storage or embedded hardware etc.\r\n    };\r\n}\r\n\r\n//Note, you can use deviceDefinition.ToDescriptionDocumentText() to retrieve the data to \r\n//return from the Location end point, you just need to get that data to your service\r\n//implementation somehow. Depends on how you've implemented your service.\r\n\r\n_Publisher = new SsdpDevicePublisher();\r\n_Publisher.AddDevice(deviceDefinition);    \r\n```\r\n\r\n### Discovering Devices\r\nBasically, just create an SsdpDeviceLocator object and call the search method. By default the method will search for all devices, but you can specify a search target string in the following formats;\r\n\r\n* ssdp:all\r\n* upnp:rootdevice\r\n* uuid:&lt;device's unique identifier&gt;\r\n* urn:&lt;fully qualified device type&gt;\r\n\r\nThe format of a fully qualified device type is;\r\nurn:&lt;device namespace&gt;:device:&lt;device type&gt;:&lt;device version&gt;\r\n\r\ni.e\r\n\r\n* uuid:CAA42739-8F87-4463-B747-6F6DDB301A06\r\n* urn:schemas-upnp-org:device:Basic:1\r\n\r\n#### Simple Search\r\nSimple search is easy but requires you to wait for the full search to finish before getting any results back. \r\nThis is asynchronous and  returns a task which you can choose to wait on (or not), but you must wait for the task to complete before accessing the results.\r\n\r\n```C#\r\nusing Rssdp;\r\n\r\n//Call this method from somewhere to begin the search.\r\npublic async void SearchForDevices()\r\n{\r\n    // This code goes in a method somewhere.\r\n    using (var deviceLocator = new SsdpDeviceLocator())\r\n    {\r\n        var foundDevices = await deviceLocator.SearchAsync(); // Can pass search arguments here (device type, uuid). No arguments means all devices.\r\n\r\n        foreach (var foundDevice in foundDevices)\r\n        {\r\n        \t// Device data returned only contains basic device details and location ]\r\n        \t// of full device description.\r\n        \tConsole.WriteLine(\"Found \" + foundDevice.Usn + \" at \" + foundDevice.DescriptionLocation.ToString());\r\n            \r\n        \t// Can retrieve the full device description easily though.\r\n        \tvar fullDevice = await foundDevice.GetDeviceInfo();\r\n        \tConsole.WriteLine(fullDevice.FriendlyName);\r\n        \tConsole.WriteLine();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### Event Driven Search & Discovery via Notifications\r\nEvent driven search is the same as 'simple' search but instead of looking at the task return value, you subscribe to the DeviceAvailable and DeviceUnavailable events to handle results.\r\nThese events are raised each time a search response is received, as well as whenever a status notification is broadcast from a device. By responding to the events you \r\ncan process results sooner than waiting for all results to come back from a completed task. You can also monitor for new devices arriving on the network or existing devices disappearing \r\nwithout having to repeatedly call search. Notifications can also be used in conjunction with simple search, just call the StartListeningForNotifications method before searching and handle the events.\r\n\r\n```C#\r\nusing Rssdp;\r\n// Define _DeviceLocator as a field so it doesn't get GCed after the method ends, and it can\r\n// continue to listen for notifications until it is explicitly stopped \r\n// (with a call to _DeviceLocator.StopListeningForNotifications();)\r\nprivate SsdpDeviceLocator _DeviceLocator;\r\n\r\n// Call this method from somewhere in your code to start the search.\r\npublic void BeginSearch()\r\n{\r\n    _DeviceLocator = new SsdpDeviceLocator();\r\n\r\n    // (Optional) Set the filter so we only see notifications for devices we care about \r\n    // (can be any search target value i.e device type, uuid value etc - any value that appears in the \r\n    // DiscoverdSsdpDevice.NotificationType property or that is used with the searchTarget parameter of the Search method).\r\n    _DeviceLocator.NotificationFilter = \"upnp:rootdevice\";\r\n\r\n    // Connect our event handler so we process devices as they are found\r\n    \\_DeviceLocator.DeviceAvailable += deviceLocator_DeviceAvailable;\r\n\r\n    // Enable listening for notifications (optional)\r\n    _DeviceLocator.StartListeningForNotifications();\r\n\r\n    // Perform a search so we don't have to wait for devices to broadcast notifications \r\n    // again to get any results right away (notifications are broadcast periodically).\r\n    _DeviceLocator.SearchAsync();\r\n\r\n    Console.ReadLine();\r\n}\r\n\r\n// Process each found device in the event handler\r\nasync static void deviceLocator_DeviceAvailable(object sender, DeviceAvailableEventArgs e)\r\n{\r\n\t//Device data returned only contains basic device details and location of full device description.\r\n\tConsole.WriteLine(\"Found \" + e.DiscoveredDevice.Usn + \" at \" + e.DiscoveredDevice.DescriptionLocation.ToString());\r\n    \r\n\t//Can retrieve the full device description easily though.\r\n\tvar fullDevice = await e.DiscoveredDevice.GetDeviceInfo();\r\n\tConsole.WriteLine(fullDevice.FriendlyName);\r\n\tConsole.WriteLine();\r\n}\r\n```\r\n\r\n## Why RSSDP?\r\n*Aren't there already lots of SSDP implementations?*\r\n\r\nI needed to find a custom/proprietary service on local networks from a mobile device. I decided this had been done before and I shouldn't re-invent the wheel so I started looking for \r\nexisting, standard protocols that did this. I decided Zeroconf and SSDP seemed like the best two, and Zeroconf looked like the more efficient, less overhead option. Unfortunately I also need a solution where\r\n\r\n* I could publish a device. Many other libraries only focus on discovery.\r\n* the publish component runs on (at least) .Net 4.0, without relying on any external services. Many other implementations are just wrappers around a Windows or Linux service, which I couldn't guarantee would be installed/enabled etc.\r\n* the discovery component (at least) runs on Windows Phone and Xamarin.iOS. Preferably also .Net 4.0, Xamain.Android, WinRT and Compact Framework projects (I haven't yet done Android/WinRT/CF but they should be fairly easy when I get around to them). A lot of other implementations don't support the Xamarin platforms.\r\n* the API was consistent across platforms so I can write as little code with as little conditional compilation as possible (especially in Xamarin Forms projects).\r\n* the library wasn't massive and didn't have huge numbers of dependencies, I want to keep my deployment footprint as small as possible.\r\n* the library guided me (at least a little) towards publishing devices correctly, i.e correct device types, not leaving out required fields etc.\r\n\r\nSadly, I couldn't find a .Net implementation that met the criteria (I found some Node.Js and implementations in other languages that might have worked, but not in my environment/with my tools). Maybe I didn't look hard enough \r\nbut that's where I ended up. Having failed on Zeroconf I went looking for SSDP implementations that met the same goals, and had exactly the same problem. I then looked at implementing each protocol and while Zeroconf looked \r\nbetter overall, it *seemed* less well documented and harder to implement. At the point where I decided this wheel needed reinventing** I chose SSDP.\r\n\r\n ** Have you ever thought about how many different, useful, kinds of wheel there are in the world? Train wheels won't work on a bicycle, and bicycle wheels won't work on a car etc. Often people who say don't re-invent the wheel \r\nhaven't really considered how many variations of a wheel might be needed.\r\n\r\n## References\r\nReference materials used while writing this library, or that may be useful to people working with RSSDP who are not familiar with SSDP/UPnP device types and protocols.\r\n\r\n* [SSDP Draft 1.03 Specification](http://tools.ietf.org/html/draft-cai-ssdp-v1-03 \"SSDP Draft Spec 1.03\")\r\n* [UPnP 1.0 Specification](http://tools.ietf.org/html/draft-cai-ssdp-v1-03 \"UPnP 1.0 Spec\")\r\n* [UPnP 1.1 Specification](http://www.upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.0-20080424.pdf \"UPnP 1.1 Spec\")\r\n* [HTTP 1.1 Specification](http://tools.ietf.org/html/rfc2616 \"HTTP 1.1 Spec\")\r\n\r\n* [UPnP Device Types and Descriptions](http://upnp.org/index.php/sdcps-and-certification/standards/sdcps/ \"UPnP Device Types\")\r\n* [UPnP Developer Tools](http://opentools.homeip.net/dev-tools-for-upnp)\r\n","google":"UA-60315482-1","note":"Don't delete this file! It's used internally to help with page regeneration."}